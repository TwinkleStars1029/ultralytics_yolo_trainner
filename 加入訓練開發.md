# 加入訓練：UI × Docker 執行與進度顯示設計說明

本文檔說明如何將既有的 Docker 訓練流程（以 `docker exec` 在既有容器內執行 `train_obj.py`）整合進目前的桌面 UI 工具，讓使用者能透過介面發起訓練、看到即時訓練日誌與進度、停止／續訓、並在訓練完成後取用輸出成果。

---

## 1. 目標與現況

- 現況：
  - 手動整理資料後，透過 CMD 進入已啟動的 Docker 容器執行訓練：
    - `docker exec -i -t ultralytics_1016 /bin/bash`
    - `python train_obj.py --project="20241206_K2_DR02_v18.1" --dataName="20241206_K2_DR02_v18.1"`
  - 可從終端機日誌看到訓練進度。

- 目標：
  - 在 UI 中提供：
    - 設定訓練參數（`project`, `dataName`, 以及可選的高階參數）。
    - 一鍵啟動訓練（於指定容器內執行）。
    - 即時顯示訓練日誌（無卡頓、可滾動、可複製）。
    - 顯示進度條（如：依 Ultralytics 的 `epoch X/Y` 推算百分比）。
    - 支援中止、續訓、與輸出結果瀏覽／開啟資料夾。

---

## 2. 使用情境與需求

- 使用情境：
  - 研究人員或標註人員準備好資料後，在 UI 選擇資料集與專案名稱後，直接按開始訓練。
  - 管理者可在 UI 監看日誌與整體進度，不需要登入容器。

- 功能需求：
  - 列出可用訓練容器（預設使用 `ultralytics_1016`）。
  - 檢查容器狀態（啟動/未啟動），並提供一鍵啟動或錯誤提示。
  - 開始訓練：以非互動 TTY 啟動（避免控制碼干擾），使用非緩衝輸出（`python -u`）。
  - 日誌串流：UI 能即時看到標準輸出，並可儲存到檔案。
  - 進度計算：解析日誌中 `epoch a/b` 或 `x/y` 字樣，更新進度。
  - 停止訓練：在容器內安全終止訓練程式。
  - 續訓：支援 Ultralytics 的 `--resume` 或載入上次權重。
  - 成果存取：訓練輸出（權重、圖表、log）需落在 Host 可存取的 volume 目錄。

---

## 3. 系統設計總覽

### 3.1 執行模式選項

- 方案 A（沿用現況）：在既有容器內 `docker exec` 執行訓練腳本。
  - 優點：改動小、啟動快、維運簡單。
  - 缺點：多個訓練併發時需自行管理；停止／恢復需要額外處理子程序。

- 方案 B（強化隔離）：每次訓練使用 `docker run` 啟動專用容器。
  - 優點：天然隔離、用 `docker logs -f` 串流更簡單、停止較直接。
  - 缺點：需設計 image/tag、掛載參數與啟停流程，初期改動略大。

本次規劃先以 方案 A 為主，保留後續升級到 方案 B 的路徑。

### 3.2 邏輯模組

- 容器管理層：列出/檢查容器、驗證必要路徑與腳本存在。
- 任務控制層：組裝訓練指令、啟動/停止/續訓、保存任務狀態（含 PID 或 session id）。
- 日誌與進度層：即時讀取 stdout、解析進度關鍵字、保留最近 N 行、寫入檔案。
- UI 呈現層：表單（參數）、控制（Start/Stop/Resume）、視圖（Log Viewer、Progress、Artifacts）。

---

## 4. 前置條件與環境

- 已安裝 Docker 與（如需）NVIDIA Container Toolkit（若使用 GPU）。
- 既有容器名稱：`ultralytics_1016`（可於 UI 設為預設值，可切換）。
- 訓練腳本：容器內存在 `train_obj.py`，且可由工作目錄執行。
- Volume 規劃（建議）：
  - Host `d:/Project/Yolo/datasets` → Container `/workspace/datasets`
  - Host `d:/Project/Yolo/runs` → Container `/workspace/runs`（或 `ultralytics/runs` 既有路徑）
  - 讓 UI 能直接讀寫資料集與輸出結果。

---

## 5. UI 設計提案

- 表單區：
  - `Container`: 下拉選單（預設 `ultralytics_1016`）。
  - `Project`: 預設為日期＋序號，如 `20241206_K2_DR02_v18.1`，可編輯。
  - `DataName`: 與資料集名稱一致（也可提供瀏覽/選擇）。
  - 進階參數（可折疊）：`epochs`, `imgsz`, `batch`, `device`, `hyp`, `weights`, `resume`, `exist_ok` 等。

- 控制區：
  - `Start Training`：啟動訓練；不可用狀態下顯示原因（容器未啟動、路徑驗證失敗）。
  - `Stop`：安全終止訓練流程（見第 8 節）。
  - `Resume`：在指定 `project` 基礎上續訓（見第 9 節）。

- 顯示區：
  - `Progress Bar`：解析 epoch 估算百分比；同時顯示 `X/Y`、ETA（可選）。
  - `Log Viewer`：即時追加（tail 模式）、可複製、支援「儲存日誌」。
  - `Artifacts`：顯示輸出路徑快捷鈕（開啟資料夾 / 檔案瀏覽）。

---

## 6. 指令執行與日誌串流

### 6.1 指令建議

- 避免 `-t`（TTY）以減少控制碼干擾；使用 `-i` 搭配非緩衝輸出：

```bash
docker exec -i ultralytics_1016 bash -lc "python -u train_obj.py --project='${PROJECT}' --dataName='${DATANAME}'"
```

- 說明：
  - `bash -lc`：在 login shell 執行，能取得環境變數與 PATH。
  - `python -u`：非緩衝 stdout，日誌能即時送回 UI。
  - 如需 GPU 指定：`CUDA_VISIBLE_DEVICES=0 python -u ...`。

### 6.2 以 Subprocess 串流（最少改動）

- UI 後端以 `subprocess.Popen([...], stdout=PIPE, stderr=STDOUT, text=True, bufsize=1)` 執行上述 `docker exec`。
- 逐行讀取 stdout，立即 append 到 UI 的 Log Viewer 與磁碟日誌檔（建議：`runs/<project>/train.log`）。
- 嚴禁使用 `-t` 或 `pty`，否則會混入控制碼或行內回車，難以解析。

偽代碼（僅作為實作參考，本文不更動程式）：

```python
cmd = [
  'docker', 'exec', '-i', container_name,
  'bash', '-lc',
  f"CUDA_VISIBLE_DEVICES={gpu} python -u train_obj.py --project='{project}' --dataName='{data_name}' {extra_args}"
]
proc = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, bufsize=1, text=True)
for line in proc.stdout:
    handle_log(line)          # 顯示於 UI、寫入檔案
    progress.update(line)     # 解析進度（見 7 節）
ret = proc.wait()
```

### 6.3 以 Docker SDK 串流（進階、控制更細）

- 以 Python Docker SDK：

```python
import docker
cli = docker.from_env()
container = cli.containers.get(container_name)
exec_id = cli.api.exec_create(container.id, cmd=f"bash -lc 'python -u train_obj.py --project={project} --dataName={data_name} {extra}'")
for chunk in cli.api.exec_start(exec_id, stream=True, demux=False):
    line = chunk.decode(errors='ignore')
    handle_log(line)
    progress.update(line)
```

- 優點：跨平台一致性較好，可取得更多狀態；缺點：需安裝 `docker` 套件、引入新依賴。

---

## 7. 進度條計算（解析 Ultralytics 日誌）

- Ultralytics 日誌常見：`Epoch 3/100`、`3/100`、或 `epoch: 3/100`。
- 建議正則：`r"(?i)\b(?:epoch\s*)?(\d+)\s*/\s*(\d+)\b"`。
- 流程：
  - 每行日誌套用正則，若匹配到 `(cur, total)`：更新 `progress = cur / total`。
  - 若行內帶有 `time` 或 `it/s` 等，可粗估 ETA（可選）。
  - 若遇到 `val:`、`metrics:` 可記錄關鍵指標以便 UI 顯示（最佳 mAP、loss）。

---

## 8. 停止／中止訓練（安全結束）

- 問題：`docker exec` 發出的 `Ctrl+C` 未必能直接傳遞到子程序。
- 建議做法：記錄訓練進程 PID，或以關鍵字 `pkill -f` 終止。

簡化策略：

```bash
docker exec ultralytics_1016 bash -lc "pkill -f 'python -u train_obj.py' || true"
```

- 若訓練腳本有包裹器，可在包裹器內捕捉 SIGINT/SIGTERM 並安全儲存檢查點。
- 若使用 Docker SDK，亦可透過 `exec_resize`/`exec_inspect` 等 API 輔助判斷狀態，再下達終止命令。

---

## 9. 續訓（Resume）

- Ultralytics 一般支援：`--resume` 或指定 `--weights path/to/last.pt`。
- UI 端可提供：
  - 列出 `runs/<project>/weights/last.pt` 快速選擇。
  - 勾選「續訓」則自動帶入 `--resume` 或 `--weights`。

指令範例：

```bash
docker exec -i ultralytics_1016 bash -lc \
  "python -u train_obj.py --project='${PROJECT}' --dataName='${DATANAME}' --resume"
```

---

## 10. 產出與路徑規劃（Artifacts）

- 目標：UI 能直接讀寫，方便檢視成果與後處理。
- 建議路徑：
  - Host：`d:/Project/Yolo/runs/<project>/...`
  - Container：`/ultralytics/runs/<project>/...`
- 具體做法：容器在建立或啟動時即完成 volume 掛載；訓練腳本使用 `--project` 指向該路徑（或使用預設 `runs` 下子目錄）。
- UI 顯示：
  - 「開啟輸出資料夾」按鈕（Host 路徑）。
  - 「匯出日誌」直接複製 `train.log` 至使用者指定位置。

---

## 11. 錯誤處理與回報

- 容器不存在／未啟動：
  - 檢查：`docker ps -a`、`docker inspect`。
  - UI 顯示明確錯誤並提供「嘗試啟動」按鈕（若允許）。

- 腳本或路徑不存在：
  - 先於容器內檢查：`test -f train_obj.py`、`test -d /workspace/datasets/<dataName>`。
  - 失敗時中止並提示修正方式。

- 權限問題：
  - Volume 掛載時加入適當 UID/GID 或在容器內調整目錄權限。

- 日誌亂碼／控制碼：
  - 移除 `-t`；必要時過濾 ANSI 控制碼（正則清洗）。

---

## 12. 安全與資源

- GPU 指定：`CUDA_VISIBLE_DEVICES=0`（或於 UI 提供裝置選擇）。
- 資源限制（若改為 `docker run`）：`--gpus`, `--cpus`, `--memory`。
- 監控：可在 UI 顯示簡要 GPU/CPU 使用率（選配，需額外取樣）。

---

## 13. 測試計畫（手動驗證）

1) 小型資料集 + `--epochs 1` 煙霧測試，確認：
   - 任務可啟動、日誌能即時顯示且無亂碼。
   - 進度條能從 `0 → 100%`。
   - 任務結束碼正確傳回（成功/失敗）。

2) 中止/續訓測試：
   - 執行數個 epoch 後中止；
   - 檢查是否保存 `last.pt`；
   - 使用 `--resume` 成功從中止點繼續。

3) 產出檢查：
   - 確認 `runs/<project>/` 產出包含權重、曲線、日誌。
   - UI 「開啟輸出資料夾」、「匯出日誌」能正常工作。

4) 錯誤注入：
   - 刻意填錯 `dataName` 或停止容器，確認 UI 錯誤訊息易懂。

---

## 14. 最小化實作清單（MVP）

- 核心流程：
  - [ ] UI 表單：Container / Project / DataName / Optional args。
  - [ ] 啟動訓練：以 `docker exec -i bash -lc 'python -u ...'` 執行。
  - [ ] 串流日誌：逐行追加至 UI 與 `runs/<project>/train.log`。
  - [ ] 進度解析：匹配 `epoch a/b` 更新百分比。
  - [ ] 停止訓練：`pkill -f` 簡化終止。
  - [ ] 續訓：勾選 `--resume` 或指定 `weights`。
  - [ ] 成果開啟：連到 Host 的 `runs/<project>`。

---

## 15. 常見問題（FAQ）

- Q：為何不加 `-t`？
  - A：`-t` 會產生 TTY 控制碼，UI 端顯示與解析會變亂，建議移除。

- Q：日誌有延遲？
  - A：請使用 `python -u`（非緩衝輸出），並確保管線 `bufsize=1`、`text=True`。

- Q：如何限制使用哪張 GPU？
  - A：在 `bash -lc` 前置 `CUDA_VISIBLE_DEVICES=<id>`，或 UI 提供選擇。

- Q：如何同時跑兩個訓練？
  - A：可行，但需注意 GPU/CPU 資源；以 方案 B（專用容器）隔離更佳。

---

## 16. 附錄：指令與偽代碼

### 16.1 直接指令（沿用現況）

```bash
# 啟動訓練（非互動、非 TTY）
docker exec -i ultralytics_1016 bash -lc \
  "python -u train_obj.py --project='20241206_K2_DR02_v18.1' --dataName='20241206_K2_DR02_v18.1'"

# 續訓
docker exec -i ultralytics_1016 bash -lc \
  "python -u train_obj.py --project='20241206_K2_DR02_v18.1' --dataName='20241206_K2_DR02_v18.1' --resume"

# 停止訓練
docker exec ultralytics_1016 bash -lc "pkill -f 'python -u train_obj.py' || true"
```

### 16.2 UI 後端偽代碼（Subprocess）

```python
def start_training(container, project, data_name, extra_args, gpu=None):
    env_prefix = f"CUDA_VISIBLE_DEVICES={gpu} " if gpu is not None else ""
    cmd = [
        'docker', 'exec', '-i', container,
        'bash', '-lc',
        f"{env_prefix}python -u train_obj.py --project='{project}' --dataName='{data_name}' {extra_args}"
    ]
    return subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, text=True, bufsize=1)

def stream_logs(proc):
    for line in proc.stdout:
        append_to_ui(line)
        save_to_file(line)
        progress.try_update(line)

def stop_training(container):
    kill_cmd = [
        'docker', 'exec', container,
        'bash', '-lc', "pkill -f 'python -u train_obj.py' || true"
    ]
    subprocess.run(kill_cmd)
```

---

## 17. 之後可考慮的優化

- 升級至 方案 B：每次訓練使用專用容器，便於 `docker logs -f` 串流、資源隔離與生命週期管理。
- 抽象任務管理：支援多任務併發與排程、工作隊列（如 `RQ`/`Celery`）。
- 結果小看板：自動擷取最佳權重、mAP、loss 曲線快照並顯示。
- 產出歸檔：完成後自動打包 `runs/<project>` 方便歸檔或上傳。

---

以上為不更動現有程式的整合設計與落地方案，後續若確認要實作，依本文件各節逐項完成即可。

---

## 18. 訓練完成後導出 ONNX 與 OpenVINO IR

本節說明如何在訓練完成後，由 UI 觸發模型導出為 ONNX，並可選擇再轉換為 OpenVINO IR（XML/BIN）。維持與前述相同的 Docker 執行模式，並同樣以串流日誌顯示進度。

### 18.1 導出為 ONNX（Ultralytics）

- 產出來源：`runs/<project>/weights/best.pt` 或 `last.pt`。
- 推薦方式一（CLI，Ultralytics v8）：

```bash
docker exec -i ultralytics_1016 bash -lc \
  "yolo export model='/ultralytics/runs/<project>/weights/best.pt' format=onnx opset=12 imgsz=640 dynamic=True"
```

- 推薦方式二（Python API）：

```bash
docker exec -i ultralytics_1016 bash -lc "python - <<'PY'\nfrom ultralytics import YOLO\nmodel = YOLO('/ultralytics/runs/<project>/weights/best.pt')\nmodel.export(format='onnx', opset=12, imgsz=640, dynamic=True)\nprint('ONNX exported to:', model.exporter.save_dir)\nPY"
```

- 產出位置：預設會於相同專案下建立 `onnx` 輸出，或在 `weights/` 旁生成 `best.onnx`（依 Ultralytics 版本）。建議統一導出至：`/ultralytics/runs/<project>/weights/<name>.onnx`。

- 注意事項：
  - `opset=12/13` 皆可，若後續要用 OpenVINO MO，建議使用 12 或 13。
  - `imgsz` 請與訓練設定一致；`dynamic=True` 可保留動態尺寸（某些部署需固定尺寸可設為 False）。

### 18.2 轉換為 OpenVINO IR（使用 mo）

- 先決條件：容器內需已安裝 OpenVINO Model Optimizer（`mo`）。若主訓練容器未安裝，可：
  - 在同一容器安裝 `openvino-dev`，或
  - 另啟 OpenVINO 官方容器，並以同樣的 volume 掛載 `runs` 路徑。

- 推薦指令（容器內 Linux 路徑版）：

```bash
docker exec -i ultralytics_1016 bash -lc \
  "mo --input_model /ultralytics/runs/<project>/weights/<name>.onnx \
      --output_dir /ultralytics/runs/<project>/weights \
      --data_type FP16"
```

- 若你在 Windows 主機使用 Windows 路徑（如 `D:\ADT-ultralytics\runs\...`）進行 `mo`，請確認該路徑已正確掛載進容器且容器可見；否則請改用容器內對應的 Linux 路徑（建議統一為 `/ultralytics/runs/...`）。

- 常見額外參數：
  - `--input_shape [1,3,640,640]`：若 ONNX 為動態尺寸而部署端需要固定輸入，建議指定。
  - `--data_type FP16` 或 `FP32`：依硬體選擇，GPU/CPU 多數情境建議 FP16 以兼顧精度與效能。

- 產出：同資料夾下生成 `*.xml` 與 `*.bin`（IR）。

### 18.3 UI 串接與日誌顯示

- 在 UI 新增「導出 ONNX」與「轉換 OpenVINO IR」按鈕：
  - 導出 ONNX：執行 18.1 指令，串流日誌到 Log Viewer。
  - 轉換 IR：執行 18.2 指令，串流日誌到 Log Viewer。

- 表單參數：
  - `Project`（帶出路徑）、`imgsz`、`opset`、`dynamic`，以及 IR 的 `data_type`、`input_shape`。

- 完成後顯示：
  - ONNX 路徑與檔名。
  - IR 檔（XML/BIN）路徑清單與「開啟資料夾」。

### 18.4 驗證建議

- ONNX 快速檢查（於容器內）：

```bash
python - <<'PY'
import onnx, onnxruntime as ort
m = onnx.load('/ultralytics/runs/<project>/weights/<name>.onnx')
onnx.checker.check_model(m)
sess = ort.InferenceSession('/ultralytics/runs/<project>/weights/<name>.onnx', providers=['CPUExecutionProvider'])
print('ONNX OK, inputs:', [i.name for i in sess.get_inputs()])
PY
```

- OpenVINO IR 快速檢查（若已安裝 runtime）：

```bash
python - <<'PY'
from openvino.runtime import Core
ie = Core()
net = ie.read_model('/ultralytics/runs/<project>/weights/<name>.xml')
compiled = ie.compile_model(net, 'CPU')
print('IR OK, inputs:', [i.any_name for i in net.inputs])
PY
```

### 18.5 最小化實作清單（導出與轉換）

- [ ] UI：新增「導出 ONNX」按鈕與必要參數（`imgsz/opset/dynamic`）。
- [ ] UI：新增「轉換 IR」按鈕與必要參數（`data_type/input_shape`）。
- [ ] 串流日誌：與訓練相同機制，逐行追加、可儲存。
- [ ] 成果管理：在 `runs/<project>/weights/` 顯示 `*.onnx`、`*.xml/bin`，提供「開啟資料夾」。
- [ ] 錯誤處理：ONNX/IR 檔案缺失、路徑掛載錯誤、mo 未安裝等提示。

---

## 19. 日誌串流與落地路徑最佳化

本節定義訓練輸出日誌的標準化策略：UI 即時串流顯示，同步穩定寫檔，並確保 Host 可直接存取，以利除錯與追蹤。

### 19.1 目標與原則

- 即時：啟動訓練後，stdout 每行立刻顯示在 UI 的「檢視日誌」。
- 可追溯：同內容同步寫入固定路徑的 `train.log`，便於離線檢視與回溯。
- 一致路徑：容器內一律寫到 `/ultralytics/runs/<project>/train.log`；Host 對映為 `runs/<project>/train.log`。

### 19.2 執行與串流細節

- 指令建議：保持非 TTY、非緩衝，利於即時性與解析。

```bash
docker exec -i <container> bash -lc "python -u train_obj.py --project='<PROJECT>' --dataName='<DATANAME>'"
```

- UI 後端行為：
  - 逐行讀取 stdout，立即追加到 UI。
  - 同步將每行以 UTF-8 追加寫入 Host `runs/<project>/train.log`（自動建檔）。
  - 若遇 ANSI 控制碼，可進行簡易過濾，提升可讀性。
  - 子程序完成時（`on_exit(rc)`）：
    - `rc == 0` → 追加「[Done] Training completed. Exit=0」。
    - 其餘 → 追加「[Failed] Training failed. Exit=<rc>」。

### 19.3 CLI 等價用法（非 UI 情境）

- 一邊看一邊存檔（推薦）：

```bash
docker exec -i ultralytics_1016 bash -lc \
  "python -u train_obj.py --project='<PROJECT>' --dataName='<DATANAME>' 2>&1 | tee -a /ultralytics/runs/<project>/train.log"
```

- 只寫檔（不建議）：

```bash
docker exec -i ultralytics_1016 bash -lc \
  "python -u train_obj.py --project='<PROJECT>' --dataName='<DATANAME>' > /ultralytics/runs/<project>/train.log 2>&1"
```

### 19.4 併發與歷史保留

- 預設 `train.log` 代表最近一次完整輸出，後啟動的同專案訓練會覆蓋。
- 建議同時寫入 `train_<timestamp>.log` 保存每次 session，避免覆蓋。
- 若需同專案多任務並行，建議 UI 阻擋或以唯一 session 名稱區分各自 log。

### 19.5 進度輔助（選配）

- 日誌解析：沿用第 7 節，解析 `epoch a/b` 更新進度。
- results.csv 校準：每 1–3 秒讀取 `runs/<project>/results.csv` 末行 `epoch` 值，對照總 epoch 校準百分比；最終仍以子程序結束為完成判定。

### 19.6 錯誤處理與相容性

- 路徑或權限錯誤：無法寫檔時，UI 顯示警告但不中斷顯示；提示檢查 Host↔Container volume 對映。
- 編碼問題：寫檔採用 `errors='replace'` 以避免中斷。
- 平台一致性：保持 `-i`，避免 `-t` 造成控制碼干擾；使用 `python -u` 確保即時輸出。
